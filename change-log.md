<h1>策略模式</h1>
<p>本次模式将模拟一个动作冒险游戏，可以选择一个角色，可以使用一种武器，但是武器一次只能使用一种。但是可以更换武器</p>
<h1>观察者模式</h1>
<p>本次模式将模拟一个气象站，当有新数据时，气象站就去更新不同的公告栏。分别为：当前状况，气象统计，简单预测</p>
<h1>装饰者模式</h1>
<p>本次模式将模拟一个咖啡馆，顾客需要各种类型的咖啡(如综合HouseBlend、深培DarkRoast、低咖啡因Decaf、浓缩咖啡Espresso)，并且会需要各种调味品(如：蒸奶Milk、豆浆Soy、摩卡mocha)</p>
<h1>工厂模式</h1>
<p>本此模式将模拟一个披萨店，用来生产各个地方，各种口味的披萨（注意，此地方和口味为2维变化）</p>
<h1>单例模式</h1>
<p>本次模式将模拟一个高压锅炉，显而易见，维护此锅炉的类实例不应该超过一个，不然稍有不慎就会炸炉，为安全起见，我们需要设计一种无论什么情形下都只会有一个实例的类</p>
<h1>命令模式</h1>
<p>本次命令将会模拟一个餐厅，顾客需要点餐并填好菜单，服务员只需要将菜单拿给厨师，然后厨师根据菜单做菜</p>
<h1>适配器模式</h1>
<p>本次模式将模拟一个丑小鸭变天鹅的故事</p>
<h1>外观模式</h1>
<p>本次模式将模拟一个搭建家庭影院的故事</p>
<h1>模板方法模式</h1>
<p>本次模式将模拟一个咖啡馆泡咖啡和茶的故事</p>
<h1>迭代器模式</h1>
<p>本次模式将模拟怎么方便用一种方式的读取两个厨师两种不同风格的菜单的故事</p>
<h1>组合模式</h1>
<p>本次模式将模拟继续上一个故事，老板需要在晚餐的菜单项中新加甜点菜单，这个把服务员急坏了，因为她在前一项中的迭代器将会失效。</p>
<h1>状态模式</h1>
<p>在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。</p>
<h1>代理模式</h1>
<p>在代理模式中，我们用客户端调用远程的对象的方法，就像在本地调用本地方法一样。起作用的是远程对象，但是客户端看到的就像是他在调用本地对象</p>
<h2>操作步骤为</h2>
<ol>
 <li>先编译包下的每个java类，如：javac -d . MyRemote.java、javac -d . MyRemoteImpl.java、javac -d . RemoteClient.java
 <hr />
 此时会在proxy文件中生成包com.design.proxy。然后会在里面生成每个类对应的class
 </li>
 <li>执行完上面步骤后再执行rmic com.design.proxy.MyRemoteImpl，此时会在com.design.proxy下生成一个MyRemoteImpl_Stub.class的文件</li>
 <li>然后在别的命令行下执行jdk自带的程序rmiregistry，此时远程执行的服务就已经注册到了本地的rmic服务中。</li>
 <li>然后执行java com.design.proxy.RemoteClient。此时就会看到在RemoteClient中执行了远程的对象的方法，打印了Hello, I'm Remote server，也就意味着RemoteClient中的Remote代理远程的MyRemoteImpl完成了其方法SayHello的调用.</li>
</ol>